package com.docker.vulnerability.scanner.dockerscanback.service;

import com.docker.vulnerability.scanner.dockerscanback.dto.ImageDto;
import com.docker.vulnerability.scanner.dockerscanback.entity.Image;
import com.docker.vulnerability.scanner.dockerscanback.mapper.ImageMapper;
import com.docker.vulnerability.scanner.dockerscanback.repository.ImageRepository;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.Collectors;

@Service
@AllArgsConstructor
public class DockerService {

    private ImageRepository imageRepository;
    private final ImageMapper imageMapper;

    public ImageDto saveImage(ImageDto imageDto) throws InterruptedException, IOException {
        Image image = imageMapper.map(imageDto);
        String str = image.getRepository();
        if (str.contains(":")) {
            String[] arrOfStr = str.split(":", 2);
            image.setRepository(arrOfStr[0]);
            image.setTag(arrOfStr[1]);
        } else {
            image.setTag("latest");
        }

        Timestamp timestamp = new Timestamp(System.currentTimeMillis());
        image.setPulledOn(timestamp);

        image = imageRepository.save(image);
        return imageMapper.map(image);
    }

    private List<String> getResults(ProcessBuilder builder) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        List<String> results = new ArrayList<String>();
        try {
            Process process = builder.start();
            ProcessReader task = new ProcessReader(process.getInputStream());
            Future<List<String>> future = pool.submit(task);

            results = future.get();
            for (String res : results) {
                System.out.println(res);
            }

            int exitcode = process.waitFor();

            System.out.println("Exit code: " + exitcode);

        } catch (Exception e) {
            System.out.println(e);
        } finally {
            pool.shutdown();
        }
        return results;
    }

    public List<String> scanImage(ImageDto imageDto) {
        ProcessBuilder builder = new ProcessBuilder();
        builder.command(System.getProperty("user.dir") + "\\scripts\\scan.bat", imageDto.getRepository() + ":" + imageDto.getTag());
        return getResults(builder);
    }

    public static class ProcessReader implements Callable {
        private InputStream inputStream;
        public ProcessReader(InputStream inputStream) {
            this.inputStream = inputStream;
        }

        @Override
        public Object call() throws Exception {
            return new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.toList());
        }
    }
}
