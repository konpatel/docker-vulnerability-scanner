package com.docker.vulnerability.scanner.dockerscanback.service;

import com.docker.vulnerability.scanner.dockerscanback.dto.ImageDto;
import com.docker.vulnerability.scanner.dockerscanback.dto.UserImageDto;
import com.docker.vulnerability.scanner.dockerscanback.entity.Image;
import com.docker.vulnerability.scanner.dockerscanback.entity.UserToken;
import com.docker.vulnerability.scanner.dockerscanback.mapper.ImageMapper;
import com.docker.vulnerability.scanner.dockerscanback.mapper.UserTokenMapper;
import com.docker.vulnerability.scanner.dockerscanback.repository.ImageRepository;
import com.docker.vulnerability.scanner.dockerscanback.repository.UserTokenRepository;
import com.google.gson.Gson;
import lombok.AllArgsConstructor;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.stream.Collectors;


@Service
@AllArgsConstructor
public class DockerService {

    private ImageRepository imageRepository;
    private UserTokenRepository userTokenRepository;
    private final ImageMapper imageMapper;
    private final UserTokenMapper userTokenMapper;

    public ImageDto saveImage(UserImageDto userImageDto) throws InterruptedException, IOException {
        Optional<UserToken> userToken = userTokenRepository.findByEmail(userImageDto.getEmail());
        ImageDto imageDto = null;
        if (userToken.isPresent()) {
            Optional<Image> image = imageRepository.findByRepositoryAndTag(userImageDto.getImage().getRepository(), userImageDto.getImage().getTag());
            if (image.isPresent()) {
                imageRepository.deleteById(image.get().getId());
            }
            image = Optional.ofNullable(imageMapper.map(userImageDto.getImage()));
            if (image.get().getTag() == null) {
                image.get().setTag("latest");
            }

            Timestamp timestamp = new Timestamp(System.currentTimeMillis());
            image.get().setPulledOn(timestamp);
            image = Optional.of(imageRepository.save(image.get()));
            List<Image> images = new ArrayList<>(userToken.get().getImages());
            images.add(image.get());
            userToken.get().setImages(images);
            userTokenRepository.save(userToken.get());
            imageDto = imageMapper.map(image.get());
        } else {
            throw new RuntimeException("User does not exist");
        }
        return imageDto;
    }

    private Object getResults(ProcessBuilder builder) {
        ExecutorService pool = Executors.newSingleThreadExecutor();
        List<String> results = new ArrayList<>();
        Object scanObj = new Object();
        try {
            Process process = builder.start();
            ProcessReader task = new ProcessReader(process.getInputStream());
            Future<List<String>> future = pool.submit(task);
            results.addAll(future.get());
            results.subList(0, 4).clear();
            String stringResult = results.stream()
                    .map(Object::toString)
                    .collect(Collectors.joining());
            System.out.println(stringResult);
            Gson gson = new Gson();
            scanObj = gson.fromJson(stringResult, Object.class);
            int exitcode = process.waitFor();

            System.out.println("Exit code: " + exitcode);

        } catch (Exception e) {
            System.out.println(e);
        } finally {
            pool.shutdown();
        }
        return scanObj;
    }

    public Object scanImage(ImageDto imageDto) {
        ProcessBuilder builder = new ProcessBuilder();
        builder.command(System.getProperty("user.dir") + "\\docker-scan-back\\scripts\\scan.bat", imageDto.getRepository() + ":" + imageDto.getTag());
        return getResults(builder);
    }

    public static class ProcessReader implements Callable {
        private InputStream inputStream;

        public ProcessReader(InputStream inputStream) {
            this.inputStream = inputStream;
        }

        @Override
        public Object call() throws Exception {
            return new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.toList());
        }
    }

    public List<ImageDto> getAllImages(String email) {
        Optional<UserToken> userToken = userTokenRepository.findByEmail(email);
        List<ImageDto> images = new ArrayList<>();
        if (userToken.isPresent()) {
            images.addAll(imageMapper.mapToDtos(userToken.get().getImages()));
        }
        return images;
    }

    public void deleteImage(String id) {
        imageRepository.deleteById(id);
    }

}
